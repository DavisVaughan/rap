% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/zap.R
\name{wap}
\alias{wap}
\alias{wap_dbl}
\alias{wap_lgl}
\alias{wap_int}
\alias{wap_chr}
\alias{wap_raw}
\alias{wap_dfr}
\alias{zap}
\alias{zap_dbl}
\alias{zap_lgl}
\alias{zap_int}
\alias{zap_chr}
\alias{zap_raw}
\alias{zap_dfr}
\title{Map over columns of a data frame simultaneously}
\usage{
wap(.tbl, ..., .ptype = list())

wap_dbl(...)

wap_lgl(...)

wap_int(...)

wap_chr(...)

wap_raw(...)

wap_dfr(...)

zap(.tbl, ..., .ptype = list())

zap_dbl(...)

zap_lgl(...)

zap_int(...)

zap_chr(...)

zap_raw(...)

zap_dfr(...)
}
\arguments{
\item{.tbl}{A data frame}

\item{...}{A single named formula.

 The rhs of the formula uses columns of `.tbl`, and each stands for a single
 observation.

 Evaluating the rhs of the formula should return a single observation of
 a type identified by `.ptype`. For example if `.ptype` is `integer()` the
 expression should evaluate to a single integer ...}

\item{.ptype}{output type. The default `list()` uses [purrr::map()] to
iterate. No checks are performed on the results.

Can be one of these special cases that take advantage of functions from `purrr`:

- `integer()` : the iteration is performed by [purrr::map_int()]
- `double()` : the iteration is performed by [purrr::map_dbl()]
- `raw()` : the iteration is performed by [purrr::map_raw()]
- `logical()` : the iteration is performed by [purrr::map_lgl()]
- `character()` : the iteration is performed by [purrr::map_chr()]

Can be `data.frame()`. Each result of the formula must be a data frame of
one observation. The data frames are combined with [vctrs::vec_rbind()].

Can be a data frame of a specific type, e.g. `data.frame(x = integer(), y = double())`.
In that case the data frames must also be of one observation, but also must
be of the specified type. They are aggregated with [vctrs::vec_rbind()], passing along
the `.ptype`.

Finally, for any other value of `.ptype`, the expression should give one
observation of that type, and they are combined eventually with [vctrs::vec_c()].}
}
\value{
- `wap()` and its variants return a vector of the appropriate type, e.g. `wap_dbl()` returns
            a numeric vector, `wap_int()` returns an integer vector, ...
  - `zap()` and its variants return a data frame with the additional column
}
\description{
Map over columns of a data frame simultaneously
}
\details{
Suffixed versions of `wap()` and `zap()` are conveniences set the `.ptype`, e.g.
`wap_int(...)` is `wap(..., .ptype = integer())`, `zap_lgl(...)` is `zap(..., .ptype = logical())`
}
\examples{

library(purrr)
library(dplyr)
library(tibble)

tbl <- tibble(cyl = c(4, 6, 8), mpg = c(30, 25, 20))

# inspired from https://github.com/tidyverse/purrr/issues/280#issuecomment-270844528
# wap returns a list
tbl \%>\%
  wap(~ filter(mtcars, cyl == !!cyl, mpg < !!mpg))

# can use the .ptype to indicate the type of result
# in the vctrs sense:
tbl \%>\%
  wap(~ nrow(filter(mtcars, cyl == !!cyl, mpg < !!mpg)), .ptype = integer())

# or alternatively use the suffixed versions, Ã  la purrr:
tbl \%>\%
  wap_int(~ nrow(filter(mtcars, cyl == !!cyl, mpg < !!mpg)))

# wap(.ptype = data.frame()) or wap_dfr row binds data frames
tbl \%>\%
  wap_dfr(~ data.frame(a = cyl * 2, b = mpg + 1))

# zap adds a column to a data frame
tbl \%>\%
  zap(x = ~filter(mtcars, cyl == !!cyl, mpg < !!mpg)) \%>\%
  zap(n = ~nrow(x), .ptype = integer())

}
